{"ast":null,"code":"var _s = $RefreshSig$();\nimport { Trans } from \"@lingui/react\";\nimport { i18n } from \"@lingui/core\";\nimport { sendAnalyticsEvent } from '@uniswap/analytics';\nimport { SwapEventName } from '@uniswap/analytics-events';\nimport { formatSwapSignedAnalyticsEventProperties } from 'lib/utils/analytics';\nimport { useMemo } from 'react';\nimport { calculateGasMargin } from 'utils/calculateGasMargin';\nimport isZero from 'utils/isZero';\nimport { swapErrorToUserReadableMessage } from 'utils/swapErrorToUserReadableMessage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass InvalidSwapError extends Error {}\n\n// returns a function that will execute a swap, if the parameters are all valid\nexport default function useSendSwapTransaction(account, chainId, provider, trade,\n// trade to execute, required\nswapCalls) {\n  _s();\n  return useMemo(() => {\n    if (!trade || !provider || !account || !chainId) {\n      return {\n        callback: null\n      };\n    }\n    return {\n      callback: async function onSwap() {\n        const estimatedCalls = await Promise.all(swapCalls.map(call => {\n          const {\n            address,\n            calldata,\n            value\n          } = call;\n          const tx = !value || isZero(value) ? {\n            from: account,\n            to: address,\n            data: calldata\n          } : {\n            from: account,\n            to: address,\n            data: calldata,\n            value\n          };\n          return provider.estimateGas(tx).then(gasEstimate => {\n            return {\n              call,\n              gasEstimate\n            };\n          }).catch(gasError => {\n            console.debug('Gas estimate failed, trying eth_call to extract error', call);\n            return provider.call(tx).then(result => {\n              console.debug('Unexpected successful call after failed estimate gas', call, gasError, result);\n              return {\n                call,\n                error: /*#__PURE__*/_jsxDEV(Trans, {\n                  id: \"Unexpected issue with estimating the gas. Please try again.\"\n                }, void 0, false, void 0, this)\n              };\n            }).catch(callError => {\n              console.debug('Call threw error', call, callError);\n              return {\n                call,\n                error: swapErrorToUserReadableMessage(callError)\n              };\n            });\n          });\n        }));\n\n        // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n        let bestCallOption = estimatedCalls.find((el, ix, list) => 'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1]));\n\n        // check if any calls errored with a recognizable error\n        if (!bestCallOption) {\n          const errorCalls = estimatedCalls.filter(call => 'error' in call);\n          if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error;\n          const firstNoErrorCall = estimatedCalls.find(call => !('error' in call));\n          if (!firstNoErrorCall) throw new Error( /*i18n*/i18n._(\"Unexpected error. Could not estimate gas for the swap.\"));\n          bestCallOption = firstNoErrorCall;\n        }\n        const {\n          call: {\n            address,\n            calldata,\n            value\n          }\n        } = bestCallOption;\n        return provider.getSigner().sendTransaction({\n          from: account,\n          to: address,\n          data: calldata,\n          // let the wallet try if we can't estimate the gas\n          ...('gasEstimate' in bestCallOption ? {\n            gasLimit: calculateGasMargin(bestCallOption.gasEstimate)\n          } : {}),\n          ...(value && !isZero(value) ? {\n            value\n          } : {})\n        }).then(response => {\n          sendAnalyticsEvent(SwapEventName.SWAP_SIGNED, formatSwapSignedAnalyticsEventProperties({\n            trade,\n            txHash: response.hash\n          }));\n          if (calldata !== response.data) {\n            sendAnalyticsEvent(SwapEventName.SWAP_MODIFIED_IN_WALLET, {\n              txHash: response.hash\n            });\n            throw new InvalidSwapError( /*i18n*/i18n._(\"Your swap was modified through your wallet. If this was a mistake, please cancel immediately or risk losing your funds.\"));\n          }\n          return response;\n        }).catch(error => {\n          // if the user rejected the tx, pass this along\n          if ((error === null || error === void 0 ? void 0 : error.code) === 4001) {\n            throw new Error( /*i18n*/i18n._(\"Transaction rejected\"));\n          } else {\n            // otherwise, the error was unexpected and we need to convey that\n            console.error(`Swap failed`, error, address, calldata, value);\n            if (error instanceof InvalidSwapError) {\n              throw error;\n            } else {\n              throw new Error( /*i18n*/i18n._(\"Swap failed: {0}\", {\n                0: swapErrorToUserReadableMessage(error)\n              }));\n            }\n          }\n        });\n      }\n    };\n  }, [account, chainId, provider, swapCalls, trade]);\n}\n_s(useSendSwapTransaction, \"nwk+m61qLgjDVUp4IGV/072DDN4=\");","map":{"version":3,"names":["sendAnalyticsEvent","SwapEventName","formatSwapSignedAnalyticsEventProperties","useMemo","calculateGasMargin","isZero","swapErrorToUserReadableMessage","InvalidSwapError","Error","useSendSwapTransaction","account","chainId","provider","trade","swapCalls","callback","onSwap","estimatedCalls","Promise","all","map","call","address","calldata","value","tx","from","to","data","estimateGas","then","gasEstimate","catch","gasError","console","debug","result","error","callError","bestCallOption","find","el","ix","list","length","errorCalls","filter","firstNoErrorCall","getSigner","sendTransaction","gasLimit","response","SWAP_SIGNED","txHash","hash","SWAP_MODIFIED_IN_WALLET","code"],"sources":["/Users/dotu/repo/interface/src/lib/hooks/swap/useSendSwapTransaction.tsx"],"sourcesContent":["import { BigNumber } from '@ethersproject/bignumber'\nimport type { JsonRpcProvider, TransactionResponse } from '@ethersproject/providers'\n// eslint-disable-next-line no-restricted-imports\nimport { t, Trans } from '@lingui/macro'\nimport { sendAnalyticsEvent } from '@uniswap/analytics'\nimport { SwapEventName } from '@uniswap/analytics-events'\nimport { Trade } from '@uniswap/router-sdk'\nimport { Currency, TradeType } from '@uniswap/sdk-core'\nimport { formatSwapSignedAnalyticsEventProperties } from 'lib/utils/analytics'\nimport { useMemo } from 'react'\nimport { calculateGasMargin } from 'utils/calculateGasMargin'\nimport isZero from 'utils/isZero'\nimport { swapErrorToUserReadableMessage } from 'utils/swapErrorToUserReadableMessage'\n\ninterface SwapCall {\n  address: string\n  calldata: string\n  value: string\n}\n\ninterface SwapCallEstimate {\n  call: SwapCall\n}\n\ninterface SuccessfulCall extends SwapCallEstimate {\n  call: SwapCall\n  gasEstimate: BigNumber\n}\n\ninterface FailedCall extends SwapCallEstimate {\n  call: SwapCall\n  error: Error\n}\n\nclass InvalidSwapError extends Error {}\n\n// returns a function that will execute a swap, if the parameters are all valid\nexport default function useSendSwapTransaction(\n  account: string | null | undefined,\n  chainId: number | undefined,\n  provider: JsonRpcProvider | undefined,\n  trade: Trade<Currency, Currency, TradeType> | undefined, // trade to execute, required\n  swapCalls: SwapCall[]\n): { callback: null | (() => Promise<TransactionResponse>) } {\n  return useMemo(() => {\n    if (!trade || !provider || !account || !chainId) {\n      return { callback: null }\n    }\n    return {\n      callback: async function onSwap(): Promise<TransactionResponse> {\n        const estimatedCalls: SwapCallEstimate[] = await Promise.all(\n          swapCalls.map((call) => {\n            const { address, calldata, value } = call\n\n            const tx =\n              !value || isZero(value)\n                ? { from: account, to: address, data: calldata }\n                : {\n                    from: account,\n                    to: address,\n                    data: calldata,\n                    value,\n                  }\n\n            return provider\n              .estimateGas(tx)\n              .then((gasEstimate) => {\n                return {\n                  call,\n                  gasEstimate,\n                }\n              })\n              .catch((gasError) => {\n                console.debug('Gas estimate failed, trying eth_call to extract error', call)\n\n                return provider\n                  .call(tx)\n                  .then((result) => {\n                    console.debug('Unexpected successful call after failed estimate gas', call, gasError, result)\n                    return { call, error: <Trans>Unexpected issue with estimating the gas. Please try again.</Trans> }\n                  })\n                  .catch((callError) => {\n                    console.debug('Call threw error', call, callError)\n                    return { call, error: swapErrorToUserReadableMessage(callError) }\n                  })\n              })\n          })\n        )\n\n        // a successful estimation is a bignumber gas estimate and the next call is also a bignumber gas estimate\n        let bestCallOption: SuccessfulCall | SwapCallEstimate | undefined = estimatedCalls.find(\n          (el, ix, list): el is SuccessfulCall =>\n            'gasEstimate' in el && (ix === list.length - 1 || 'gasEstimate' in list[ix + 1])\n        )\n\n        // check if any calls errored with a recognizable error\n        if (!bestCallOption) {\n          const errorCalls = estimatedCalls.filter((call): call is FailedCall => 'error' in call)\n          if (errorCalls.length > 0) throw errorCalls[errorCalls.length - 1].error\n          const firstNoErrorCall = estimatedCalls.find<SwapCallEstimate>(\n            (call): call is SwapCallEstimate => !('error' in call)\n          )\n          if (!firstNoErrorCall) throw new Error(t`Unexpected error. Could not estimate gas for the swap.`)\n          bestCallOption = firstNoErrorCall\n        }\n\n        const {\n          call: { address, calldata, value },\n        } = bestCallOption\n\n        return provider\n          .getSigner()\n          .sendTransaction({\n            from: account,\n            to: address,\n            data: calldata,\n            // let the wallet try if we can't estimate the gas\n            ...('gasEstimate' in bestCallOption ? { gasLimit: calculateGasMargin(bestCallOption.gasEstimate) } : {}),\n            ...(value && !isZero(value) ? { value } : {}),\n          })\n          .then((response) => {\n            sendAnalyticsEvent(\n              SwapEventName.SWAP_SIGNED,\n              formatSwapSignedAnalyticsEventProperties({ trade, txHash: response.hash })\n            )\n            if (calldata !== response.data) {\n              sendAnalyticsEvent(SwapEventName.SWAP_MODIFIED_IN_WALLET, { txHash: response.hash })\n              throw new InvalidSwapError(\n                t`Your swap was modified through your wallet. If this was a mistake, please cancel immediately or risk losing your funds.`\n              )\n            }\n            return response\n          })\n          .catch((error) => {\n            // if the user rejected the tx, pass this along\n            if (error?.code === 4001) {\n              throw new Error(t`Transaction rejected`)\n            } else {\n              // otherwise, the error was unexpected and we need to convey that\n              console.error(`Swap failed`, error, address, calldata, value)\n\n              if (error instanceof InvalidSwapError) {\n                throw error\n              } else {\n                throw new Error(t`Swap failed: ${swapErrorToUserReadableMessage(error)}`)\n              }\n            }\n          })\n      },\n    }\n  }, [account, chainId, provider, swapCalls, trade])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}